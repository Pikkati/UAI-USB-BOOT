name: Auto Merge Pull Requests

on:
  workflow_dispatch: {}
  schedule:
    - cron: '0 * * * *' # hourly
  pull_request:
    types: [opened, reopened, synchronize, ready_for_review]
  push:
    branches: [ main ]

permissions:
  pull-requests: write
  contents: read
  checks: read
  statuses: read
  issues: write

jobs:
  credit_check:
    uses: ./.github/workflows/actions-credit-guard-enhanced.yml
    with:
      estimated_minutes: 10
      threshold_percent: 3
      force_local: true
      fallback_runner: '["self-hosted","docker-swarm"]'
  auto-merge:
    needs: [credit_check]
    runs-on: ${{ fromJson(needs.credit_check.outputs.runner) }}
    steps:
      - name: Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5

      - name: Auto-merge eligible PRs
        uses: actions/github-script@d7906e4ad0b1822421a7e6a35d5ca353c962f410
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const forbiddenLabels = ['do not merge', 'do-not-merge', 'wip', 'work in progress', 'hold'];
            const maxMerges = 25;
            let merges = [];
            let skipped = [];

            // List open PRs
            const pullsRes = await github.rest.pulls.list({ owner, repo, state: 'open', per_page: 100 });
            const pulls = pullsRes.data || [];

            for (const pr of pulls) {
              if (merges.length >= maxMerges) break;

              try {
                if (pr.draft) { skipped.push({ pr, reason: 'draft' }); continue; }

                const labels = (pr.labels || []).map(l => String(l.name).toLowerCase());
                if (labels.some(l => forbiddenLabels.includes(l))) { skipped.push({ pr, reason: 'has forbidden label' }); continue; }

                // Get fresh mergeability information
                let full = (await github.rest.pulls.get({ owner, repo, pull_number: pr.number })).data;
                let retries = 0;
                while (full.mergeable === null && retries < 6) {
                  await new Promise(r => setTimeout(r, 2000));
                  full = (await github.rest.pulls.get({ owner, repo, pull_number: pr.number })).data;
                  retries++;
                }

                if (!full.mergeable) { skipped.push({ pr, reason: `not mergeable (state=${full.mergeable_state})` }); continue; }

                // Check combined status for head SHA
                const status = await github.rest.repos.getCombinedStatusForRef({ owner, repo, ref: pr.head.sha });
                if (!status || status.data.state !== 'success') { skipped.push({ pr, reason: `status checks not successful (state=${status?.data?.state})` }); continue; }

                // Attempt merge
                const mergeRes = await github.rest.pulls.merge({ owner, repo, pull_number: pr.number, merge_method: 'merge', commit_title: `Auto-merged PR #${pr.number}: ${pr.title} [automerged]`, commit_message: `Auto-merged by workflow ${context.runId}` });

                if (mergeRes && mergeRes.data && mergeRes.data.merged) {
                  merges.push({ pr, mergeCommit: mergeRes.data.merge_commit_sha });
                  await github.rest.issues.createComment({ owner, repo, issue_number: pr.number, body: `✅ This PR was automatically merged by workflow run ${context.runId}.` });
                } else {
                  skipped.push({ pr, reason: `merge attempt failed: ${mergeRes?.data?.message || 'unknown'}` });
                }

              } catch (err) {
                skipped.push({ pr, reason: `exception: ${err.message || err}` });
                console.log(`Error processing PR #${pr.number}:`, err);
              }
            }

            // Create or update a report issue
            const reportTitle = 'Automated PR Merge Report';
            const now = new Date().toISOString();
            let body = `Automated PR Merge Report - ${now}\n\n`;
            body += `Merged (${merges.length}):\n`;
            for (const m of merges) {
              body += ` - [#${m.pr.number}](${m.pr.html_url}) ${m.pr.title} (merge commit: ${m.mergeCommit})\n`;
            }
            body += `\nSkipped (${skipped.length}):\n`;
            for (const s of skipped) {
              body += ` - [#${s.pr.number}](${s.pr.html_url}) ${s.pr.title} — ${s.reason}\n`;
            }

            // Find existing issue
            const issues = await github.rest.issues.listForRepo({ owner, repo, state: 'open', per_page: 100 });
            let report = issues.data.find(i => i.title === reportTitle);
            if (report) {
              await github.rest.issues.createComment({ owner, repo, issue_number: report.number, body });
            } else {
              await github.rest.issues.create({ owner, repo, title: reportTitle, body });
            }

            console.log(`Auto-merge finished: merged=${merges.length}, skipped=${skipped.length}`);
