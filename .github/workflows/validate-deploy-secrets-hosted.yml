name: Validate Deploy Secrets (Hosted Fallback)

on:
  workflow_dispatch:
    inputs:
      auto_dispatch:
        description: 'When true, dispatch successful provider deploys automatically (true/false)'
        required: false
        default: 'false'
      debug_dispatch:
        description: 'When true, run debug checks on WORKFLOW_DISPATCH_TOKEN and attempt direct dispatch (true/false)'
        required: false
        default: 'false'

permissions:
  contents: read
  issues: write
  actions: write

jobs:
  validate:
    # Fallback diagnostics (now runs on self-hosted per No Hosted policy)
    runs-on: [self-hosted, docker-swarm]
    steps:
      - name: Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5

      - name: Setup Node.js
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020
        with:
          node-version: '20'

      - name: Install utilities
        run: sudo apt-get update -y && sudo apt-get install -y jq curl || true

      - name: Validate Cloudflare token
        id: cloudflare
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        run: |
          echo "Checking Cloudflare token (fallback diagnostics - self-hosted)..."
          status=0
          if [ -z "$CLOUDFLARE_API_TOKEN" ]; then
            echo "::warning::CLOUDFLARE_API_TOKEN is not set. Create a token with scopes: Account:Read, User Details:Read, Workers Scripts:Write, Workers Routes:Write, AI:Write and save it as CLOUDFLARE_API_TOKEN."
            status=1
          else
            # Sanity checks
            if echo "$CLOUDFLARE_API_TOKEN" | grep -qE "^Bearer\b"; then
              echo "::warning::CLOUDFLARE_API_TOKEN appears to include a 'Bearer ' prefix. Save the raw token only (no 'Bearer ' prefix)."
            fi
            if echo "$CLOUDFLARE_API_TOKEN" | grep -qE "\s"; then
              echo "::warning::CLOUDFLARE_API_TOKEN contains whitespace/newline characters. Ensure the secret is a single-line token with no extra spaces."
            fi

            resp=$(curl -sS -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" "https://api.cloudflare.com/client/v4/user/tokens/verify") || resp=""
            echo "$resp" | jq -r '.messages[]?.message' || true
            ok=$(echo "$resp" | jq -r '.success // false')
            if [ "$ok" != "true" ]; then
              if echo "$resp" | grep -qi "Invalid format for Authorization header"; then
                echo "::warning::Cloudflare token verification failed: Invalid format for Authorization header. Common causes: stored secret includes the string 'Bearer ' prefix or contains trailing newlines/whitespace. Recreate the token and store the raw token value (no 'Bearer ')."
              else
                echo "::warning::Cloudflare token verification failed. Please create a token with scopes: Account:Read, User Details:Read, Workers Scripts:Write, Workers Routes:Write, AI:Write and save it as CLOUDFLARE_API_TOKEN. Response: $resp"
              fi
              status=1
            else
              npm install -g wrangler@^3.0.0 >/dev/null 2>&1 || true
              w_out=$(wrangler whoami --token="$CLOUDFLARE_API_TOKEN" 2>&1 || true)
              echo "$w_out"
              if echo "$w_out" | grep -qi "Unable to retrieve email"; then
                echo "::warning::Cloudflare API token is missing the 'User Details:Read' permission. Recreate token with: Account:Read, User Details:Read, Workers Scripts:Write, Workers Routes:Write, AI:Write."
                status=1
              fi
            fi
          fi
          echo "status=$status" >> $GITHUB_OUTPUT

      - name: Validate Netlify token
        id: netlify
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}
        run: |
          echo "Checking Netlify token (fallback diagnostics - self-hosted)..."
          status=0
          if [ -z "$NETLIFY_AUTH_TOKEN" ]; then
            echo "::warning::NETLIFY_AUTH_TOKEN is not set. Create a Netlify Personal Access Token and save it as NETLIFY_AUTH_TOKEN."
            status=1
          else
            resp=$(curl -sS -H "Authorization: Bearer $NETLIFY_AUTH_TOKEN" "https://api.netlify.com/api/v1/user" ) || resp=""
            if ! echo "$resp" | jq -e '.id' > /dev/null 2>&1; then
              echo "::warning::NETLIFY_AUTH_TOKEN invalid/expired. Response: $resp"
              status=1
            else
              if [ -n "$NETLIFY_SITE_ID" ]; then
                site_resp=$(curl -sS -H "Authorization: Bearer $NETLIFY_AUTH_TOKEN" "https://api.netlify.com/api/v1/sites/$NETLIFY_SITE_ID") || site_resp=""
                if echo "$site_resp" | jq -e '.id' > /dev/null 2>&1; then
                  echo "Netlify token can access site $NETLIFY_SITE_ID."
                else
                  if echo "$site_resp" | grep -iq "Forbidden"; then
                    echo "::warning::NETLIFY_AUTH_TOKEN does not have access to site $NETLIFY_SITE_ID. Ensure token belongs to a user with deploy rights."
                  else
                    echo "::warning::Could not access site $NETLIFY_SITE_ID. Response: $site_resp"
                  fi
                  status=1
                fi
              else
                echo "::notice::NETLIFY_SITE_ID not set; skipping site access validation. Set NETLIFY_SITE_ID in repo secrets to validate site permissions."
              fi
            fi
          fi
          echo "status=$status" >> $GITHUB_OUTPUT

      - name: Validate Vercel token
        id: vercel
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
        run: |
          echo "Checking Vercel token (fallback diagnostics - self-hosted)..."
          status=0
          if [ -z "$VERCEL_TOKEN" ]; then
            echo "::warning::VERCEL_TOKEN is not set. Create a Vercel token for a user that has access to the target team/project and save it as VERCEL_TOKEN."
            status=1
          else
            npm install -g vercel@latest >/dev/null 2>&1 || true
            out=$(vercel whoami --token=$VERCEL_TOKEN 2>&1 || true)
            echo "$out"
            if echo "$out" | grep -qi "Not authenticated\|Unauthorized\|not logged in"; then
              echo "::warning::VERCEL_TOKEN invalid or cannot authenticate. Create/update a token and save it as VERCEL_TOKEN."
              status=1
            fi
            if [ -n "$VERCEL_PROJECT_ID" ]; then
              proj=$(vercel projects inspect $VERCEL_PROJECT_ID --token=$VERCEL_TOKEN 2>&1 || true)
              echo "$proj"
              if echo "$proj" | grep -qi "not found\|You do not have permission"; then
                echo "::warning::Vercel token user does not have access to the project or project not found. Ensure token user is a member of the team/project and the project id is correct."
                status=1
              fi
            else
              echo "::notice::VERCEL_PROJECT_ID not set; skipping project inspection."
            fi
          fi
          echo "status=$status" >> $GITHUB_OUTPUT

      - name: Create or update issue if failures
        if: always()
        uses: actions/github-script@d7906e4ad0b1822421a7e6a35d5ca353c962f410
        env:
          CF_STATUS: ${{ steps.cloudflare.outputs.status }}
          NT_STATUS: ${{ steps.netlify.outputs.status }}
          VC_STATUS: ${{ steps.vercel.outputs.status }}
        with:
          script: |
            const cf = Number(process.env.CF_STATUS || 0);
            const nt = Number(process.env.NT_STATUS || 0);
            const vc = Number(process.env.VC_STATUS || 0);
            const total = cf + nt + vc;
            if (total === 0) {
              console.log("No failures detected; no issue created.");
              return;
            }
            const title = "CI: Deploy token checks failed — update repo secrets";
            const body = `The automated deploy token validation detected failures:\n\n- Cloudflare: ${cf ? 'FAIL' : 'OK'}\n- Netlify: ${nt ? 'FAIL' : 'OK'}\n- Vercel: ${vc ? 'FAIL' : 'OK'}\n\nPlease update repository secrets (CLOUDFLARE_API_TOKEN, NETLIFY_AUTH_TOKEN, NETLIFY_SITE_ID, VERCEL_TOKEN, VERCEL_PROJECT_ID, VERCEL_ORG_ID) and re-run the validation workflow. See Cloudflare required scopes: Account:Read, User Details:Read, Workers Scripts:Write, Workers Routes:Write, AI:Write.\n\nOnce you've updated secrets, comment **Proceed** on this issue to request an automated re-run (the system will re-validate and, if successful, may auto-dispatch provider deploy workflows).\n\nThis issue was created automatically by the CI token validator.`;
            const issues = await github.paginate(github.rest.issues.listForRepo, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 100
            });
            const existing = issues.find(i => i.title === title);
            if (existing) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existing.number,
                body: `Validation re-run detected failures at ${new Date().toISOString()}.\n\n${body}`
              });
              console.log("Updated existing issue #" + existing.number);
            } else {
              const newIssue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body
              });
              console.log("Created issue #" + newIssue.data.number);
            }

      - name: Aggregate results
        run: |
          c=${{ steps.cloudflare.outputs.status }}
          n=${{ steps.netlify.outputs.status }}
          v=${{ steps.vercel.outputs.status }}
          echo "Cloudflare status: $c, Netlify status: $n, Vercel status: $v"
          total=$((c + n + v))
          if [ "$total" -gt 0 ]; then
            echo "::error::One or more deploy token checks failed. Review messages above and follow remediation guidance."
            exit 1
          else
            echo "All deploy provider token checks passed successfully. ✅"
          fi

# NOTE: This workflow used to be a hosted fallback. To comply with the repository "No Hosted" policy it now runs on self-hosted runners only and will not use GitHub-hosted minutes. Use `validate-deploy-secrets.yml` on self-hosted runners for full auto-dispatch behavior.
