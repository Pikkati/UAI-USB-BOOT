name: Validate Deploy Secrets

on:
  workflow_dispatch:
    inputs:
      auto_dispatch:
        description: 'When true, dispatch successful provider deploys automatically (true/false)'
        required: false
        default: 'false'
      debug_dispatch:
        description: 'When true, run debug checks on WORKFLOW_DISPATCH_TOKEN and attempt direct dispatch (true/false)'
        required: false
        default: 'false'
  schedule:
    - cron: '0 6 * * *'  # Daily at 06:00 UTC

permissions:
  contents: read
  issues: write
  actions: write

jobs:
  validate:
    runs-on: [self-hosted, docker-swarm]
    steps:
      - name: Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5

      - name: Setup Node.js
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020
        with:
          node-version: '20'

      - name: Install utilities
        run: sudo apt-get update -y && sudo apt-get install -y jq curl || true

      - name: Validate Cloudflare token
        id: cloudflare
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        run: |
          echo "Checking Cloudflare token..."
          status=0
          if [ -z "$CLOUDFLARE_API_TOKEN" ]; then
            echo "::warning::CLOUDFLARE_API_TOKEN is not set. Create a token with scopes: Account:Read, User Details:Read, Workers Scripts:Write, Workers Routes:Write, AI:Write and save it as CLOUDFLARE_API_TOKEN."
            status=1
          else
            # Basic sanity checks to catch common secret mistakes
            if echo "$CLOUDFLARE_API_TOKEN" | grep -qE "^Bearer\b"; then
              echo "::warning::CLOUDFLARE_API_TOKEN appears to include a 'Bearer ' prefix. Save the raw token only (no 'Bearer ' prefix)."
            fi
            if echo "$CLOUDFLARE_API_TOKEN" | grep -qE "\s"; then
              echo "::warning::CLOUDFLARE_API_TOKEN contains whitespace/newline characters. Ensure the secret is a single-line token with no extra spaces."
            fi

            resp=$(curl -sS -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" "https://api.cloudflare.com/client/v4/user/tokens/verify") || resp=""
            echo "$resp" | jq -r '.messages[]?.message' || true
            ok=$(echo "$resp" | jq -r '.success // false')
            if [ "$ok" != "true" ]; then
              # Specific guidance if Cloudflare returns an Authorization header format error
              if echo "$resp" | grep -qi "Invalid format for Authorization header"; then
                echo "::warning::Cloudflare token verification failed: Invalid format for Authorization header. Common causes: the stored secret includes the string 'Bearer ' prefix or contains trailing newlines/whitespace. Recreate the token and store the raw token value (no 'Bearer ')."
              else
                echo "::warning::Cloudflare token verification failed. Please create a token with scopes: Account:Read, User Details:Read, Workers Scripts:Write, Workers Routes:Write, AI:Write and save it as CLOUDFLARE_API_TOKEN. Response: $resp"
              fi
              status=1
            else
              npm install -g wrangler@^3.0.0 >/dev/null 2>&1 || true
              w_out=$(wrangler whoami --token="$CLOUDFLARE_API_TOKEN" 2>&1 || true)
              echo "$w_out"
              if echo "$w_out" | grep -qi "Unable to retrieve email"; then
                echo "::warning::Cloudflare API token is missing the 'User Details:Read' permission. Recreate token with: Account:Read, User Details:Read, Workers Scripts:Write, Workers Routes:Write, AI:Write."
                status=1
              fi
            fi
          fi
          echo "status=$status" >> $GITHUB_OUTPUT

      - name: Validate Netlify token
        id: netlify
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}
        run: |
          echo "Checking Netlify token..."
          status=0
          if [ -z "$NETLIFY_AUTH_TOKEN" ]; then
            echo "::warning::NETLIFY_AUTH_TOKEN is not set. Create a Netlify Personal Access Token and save it as NETLIFY_AUTH_TOKEN."
            status=1
          else
            resp=$(curl -sS -H "Authorization: Bearer $NETLIFY_AUTH_TOKEN" "https://api.netlify.com/api/v1/user" ) || resp=""
            if ! echo "$resp" | jq -e '.id' > /dev/null 2>&1; then
              echo "::warning::NETLIFY_AUTH_TOKEN invalid/expired. Response: $resp"
              status=1
            else
              if [ -n "$NETLIFY_SITE_ID" ]; then
                site_resp=$(curl -sS -H "Authorization: Bearer $NETLIFY_AUTH_TOKEN" "https://api.netlify.com/api/v1/sites/$NETLIFY_SITE_ID") || site_resp=""
                if echo "$site_resp" | jq -e '.id' > /dev/null 2>&1; then
                  echo "Netlify token can access site $NETLIFY_SITE_ID."
                else
                  if echo "$site_resp" | grep -iq "Forbidden"; then
                    echo "::warning::NETLIFY_AUTH_TOKEN does not have access to site $NETLIFY_SITE_ID. Ensure token belongs to a user with deploy rights."
                  else
                    echo "::warning::Could not access site $NETLIFY_SITE_ID. Response: $site_resp"
                  fi
                  status=1
                fi
              else
                echo "::notice::NETLIFY_SITE_ID not set; skipping site access validation. Set NETLIFY_SITE_ID in repo secrets to validate site permissions."
              fi
            fi
          fi
          echo "status=$status" >> $GITHUB_OUTPUT

      - name: Validate Vercel token
        id: vercel
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
        run: |
          echo "Checking Vercel token..."
          status=0
          if [ -z "$VERCEL_TOKEN" ]; then
            echo "::warning::VERCEL_TOKEN is not set. Create a Vercel token for a user that has access to the target team/project and save it as VERCEL_TOKEN."
            status=1
          else
            npm install -g vercel@latest >/dev/null 2>&1 || true
            out=$(vercel whoami --token=$VERCEL_TOKEN 2>&1 || true)
            echo "$out"
            if echo "$out" | grep -qi "Not authenticated\|Unauthorized\|not logged in"; then
              echo "::warning::VERCEL_TOKEN invalid or cannot authenticate. Create/update a token and save it as VERCEL_TOKEN."
              status=1
            fi
            if [ -n "$VERCEL_PROJECT_ID" ]; then
              proj=$(vercel projects inspect $VERCEL_PROJECT_ID --token=$VERCEL_TOKEN 2>&1 || true)
              echo "$proj"
              if echo "$proj" | grep -qi "not found\|You do not have permission"; then
                echo "::warning::Vercel token user does not have access to the project or project not found. Ensure token user is a member of the team/project and the project id is correct."
                status=1
              fi
            else
              echo "::notice::VERCEL_PROJECT_ID not set; skipping project inspection."
            fi
          fi
          echo "status=$status" >> $GITHUB_OUTPUT

      - name: Create or update issue if failures
        if: always()
        uses: actions/github-script@d7906e4ad0b1822421a7e6a35d5ca353c962f410
        env:
          CF_STATUS: ${{ steps.cloudflare.outputs.status }}
          NT_STATUS: ${{ steps.netlify.outputs.status }}
          VC_STATUS: ${{ steps.vercel.outputs.status }}
        with:
          script: |
            const cf = Number(process.env.CF_STATUS || 0);
            const nt = Number(process.env.NT_STATUS || 0);
            const vc = Number(process.env.VC_STATUS || 0);
            const total = cf + nt + vc;
            if (total === 0) {
              console.log("No failures detected; no issue created.");
              return;
            }
            const title = "CI: Deploy token checks failed — update repo secrets";
            const body = `The automated deploy token validation detected failures:\n\n- Cloudflare: ${cf ? 'FAIL' : 'OK'}\n- Netlify: ${nt ? 'FAIL' : 'OK'}\n- Vercel: ${vc ? 'FAIL' : 'OK'}\n\nPlease update repository secrets (CLOUDFLARE_API_TOKEN, NETLIFY_AUTH_TOKEN, NETLIFY_SITE_ID, VERCEL_TOKEN, VERCEL_PROJECT_ID, VERCEL_ORG_ID) and re-run the validation workflow. See Cloudflare required scopes: Account:Read, User Details:Read, Workers Scripts:Write, Workers Routes:Write, AI:Write.\n\nOnce you've updated secrets, comment **Proceed** on this issue to request an automated re-run (the system will re-validate and, if successful, may auto-dispatch provider deploy workflows).\n\nThis issue was created automatically by the CI token validator.`;
            const issues = await github.paginate(github.rest.issues.listForRepo, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 100
            });
            const existing = issues.find(i => i.title === title);
            if (existing) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existing.number,
                body: `Validation re-run detected failures at ${new Date().toISOString()}.\n\n${body}`
              });
              console.log("Updated existing issue #" + existing.number);
            } else {
              const newIssue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body
              });
              console.log("Created issue #" + newIssue.data.number);
            }

      - name: Aggregate results
        id: aggregate
        run: |
          c=${{ steps.cloudflare.outputs.status }}
          n=${{ steps.netlify.outputs.status }}
          v=${{ steps.vercel.outputs.status }}
          echo "Cloudflare status: $c, Netlify status: $n, Vercel status: $v"
          total=$((c + n + v))
          if [ "$total" -gt 0 ]; then
            echo "::error::One or more deploy token checks failed. Review messages above and follow remediation guidance."
            exit 1
          else
            echo "All deploy provider token checks passed successfully. ✅"
          fi

      - name: Update or close existing validation issue
        if: success()
        uses: actions/github-script@d7906e4ad0b1822421a7e6a35d5ca353c962f410
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const title = "CI: Deploy token checks failed — update repo secrets";
            const issues = await github.paginate(github.rest.issues.listForRepo, { owner: context.repo.owner, repo: context.repo.repo, state: 'open', per_page: 100 });
            const existing = issues.find(i => i.title === title);
            if (existing) {
              await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: existing.number, body: `Validation re-run at ${new Date().toISOString()} shows all checks passing. The validator may now auto-dispatch provider deploy workflows if requested.` });
              await github.rest.issues.update({ owner: context.repo.owner, repo: context.repo.repo, issue_number: existing.number, state: 'closed' });
              console.log('Closed issue #' + existing.number);
            } else {
              console.log('No existing validation failure issue to update.');
            }

      - name: Ensure dispatch token present (optional)
        if: ${{ success() && github.event_name == 'workflow_dispatch' && github.event.inputs.auto_dispatch == 'true' }}
        env:
          WORKFLOW_DISPATCH_TOKEN: ${{ secrets.WORKFLOW_DISPATCH_TOKEN }}
        run: |
          if [ -z "$WORKFLOW_DISPATCH_TOKEN" ]; then
            echo "::warning::WORKFLOW_DISPATCH_TOKEN is not set. The workflow will attempt to use GITHUB_TOKEN which may be blocked by repository/org settings. For reliable auto-dispatch, create a Personal Access Token (PAT) with 'repo' and 'workflow' scopes and save it as WORKFLOW_DISPATCH_TOKEN in repository secrets."
          else
            echo "Dispatch token present."
          fi

      - name: Validate dispatch token (pre-dispatch)
        if: ${{ success() && github.event_name == 'workflow_dispatch' && github.event.inputs.auto_dispatch == 'true' }}
        env:
          WORKFLOW_DISPATCH_TOKEN: ${{ secrets.WORKFLOW_DISPATCH_TOKEN }}
        run: |
          if [ -z "$WORKFLOW_DISPATCH_TOKEN" ]; then
            echo "::notice::WORKFLOW_DISPATCH_TOKEN not set; dispatch step will use GITHUB_TOKEN (may be blocked by org policy)."
            exit 0
          fi
          echo "Validating WORKFLOW_DISPATCH_TOKEN repository access..."
          resp=$(curl -sS -w '\n%{http_code}' -H "Authorization: token $WORKFLOW_DISPATCH_TOKEN" -H "Accept: application/vnd.github+json" "https://api.github.com/repos/$GITHUB_REPOSITORY/actions/workflows" 2>&1 || true)
          http_code=$(echo "$resp" | tail -n1)
          body=$(echo "$resp" | head -n -1)
          if [ "$http_code" != "200" ]; then
            echo "::error::WORKFLOW_DISPATCH_TOKEN cannot access repository workflows (HTTP $http_code). Fix: (1) ensure PAT has 'repo' + 'workflow' scopes (or fine-grained Workflows:read&write), (2) PAT includes this repo in repository access, (3) PAT owner has write+ permission on this repo. Response: $body. See docs/DEPLOY_SECRETS.md for creation steps."
            exit 1
          fi
          echo "Token validation passed; ready to dispatch."

      - name: Debug dispatch token (optional)
        if: ${{ success() && github.event_name == 'workflow_dispatch' && github.event.inputs.auto_dispatch == 'true' && github.event.inputs.debug_dispatch == 'true' }}
        env:
          WORKFLOW_DISPATCH_TOKEN: ${{ secrets.WORKFLOW_DISPATCH_TOKEN }}
        run: |
          set -eo pipefail
          if [ -z "$WORKFLOW_DISPATCH_TOKEN" ]; then
            echo "::warning::WORKFLOW_DISPATCH_TOKEN is not set; cannot run dispatch debug checks."
            exit 0
          fi
          echo "=== Token identity ==="
          curl -sS -i -H "Authorization: token $WORKFLOW_DISPATCH_TOKEN" -H "Accept: application/vnd.github+json" https://api.github.com/user | sed -n '1,200p'
          echo "=== List workflows (first 200 lines) ==="
          curl -sS -i -H "Authorization: token $WORKFLOW_DISPATCH_TOKEN" -H "Accept: application/vnd.github+json" "https://api.github.com/repos/$GITHUB_REPOSITORY/actions/workflows" | sed -n '1,200p'
          echo "=== Attempting dispatch to cloudflare-deploy.yml (ref: main) ==="
          curl -sS -i -X POST -H "Authorization: token $WORKFLOW_DISPATCH_TOKEN" -H "Accept: application/vnd.github+json" -H "Content-Type: application/json" "https://api.github.com/repos/$GITHUB_REPOSITORY/actions/workflows/cloudflare-deploy.yml/dispatches" -d '{"ref":"main"}' | sed -n '1,200p'
          echo "=== Debug dispatch step completed ==="

      - name: Dispatch deploy workflows (optional)
        if: ${{ success() && github.event_name == 'workflow_dispatch' && github.event.inputs.auto_dispatch == 'true' }}
        uses: actions/github-script@d7906e4ad0b1822421a7e6a35d5ca353c962f410
        env:
          CF_STATUS: ${{ steps.cloudflare.outputs.status }}
          NT_STATUS: ${{ steps.netlify.outputs.status }}
          VC_STATUS: ${{ steps.vercel.outputs.status }}
        with:
          github-token: ${{ secrets.WORKFLOW_DISPATCH_TOKEN }}
          script: |
            const cf = Number(process.env.CF_STATUS || 0);
            const nt = Number(process.env.NT_STATUS || 0);
            const vc = Number(process.env.VC_STATUS || 0);
            if (cf === 0) {
              await github.rest.actions.createWorkflowDispatch({ owner: context.repo.owner, repo: context.repo.repo, workflow_id: 'cloudflare-deploy.yml', ref: 'main' });
              console.log('Dispatched cloudflare-deploy.yml');
            }
            if (nt === 0) {
              await github.rest.actions.createWorkflowDispatch({ owner: context.repo.owner, repo: context.repo.repo, workflow_id: 'netlify-deploy.yml', ref: 'main' });
              console.log('Dispatched netlify-deploy.yml');
            }
            if (vc === 0) {
              await github.rest.actions.createWorkflowDispatch({ owner: context.repo.owner, repo: context.repo.repo, workflow_id: 'vercel-deploy.yml', ref: 'main', inputs: { confirm: 'CONFIRM' } });
              console.log('Dispatched vercel-deploy.yml');
            }
